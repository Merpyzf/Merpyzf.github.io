<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://merpyzf.github.io</id>
    <title>It&apos;s my life</title>
    <updated>2020-04-27T03:33:37.550Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://merpyzf.github.io"/>
    <link rel="self" href="https://merpyzf.github.io/atom.xml"/>
    <subtitle>真正的光芒，需要一点点时间</subtitle>
    <logo>https://merpyzf.github.io/images/avatar.png</logo>
    <icon>https://merpyzf.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, It&apos;s my life</rights>
    <entry>
        <title type="html"><![CDATA[Android Library 无法引用Libs目录下的jar包]]></title>
        <id>https://merpyzf.github.io/post/android-library-wu-fa-yin-yong-libs-mu-lu-xia-de-jar-bao/</id>
        <link href="https://merpyzf.github.io/post/android-library-wu-fa-yin-yong-libs-mu-lu-xia-de-jar-bao/">
        </link>
        <updated>2020-04-26T02:39:42.000Z</updated>
        <content type="html"><![CDATA[<p>通过创建一个Android Library将设备厂商提供的杂乱不堪的代码封装成一个可直接调用的AAR的时候遇到了一个问题，当在 Library 中需要引用libs下的jar时却发现找不到。</p>
<p>解决方法：修改Library库的build.gradle文件，将implementation改成compile<br>
代码如下：</p>
<pre><code>dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation project(':core')
}

</code></pre>
<p>修改后：</p>
<pre><code>dependencies {
    compile  fileTree(dir: 'libs', include: ['*.jar'])
    implementation project(':core')
}
</code></pre>
<p>重新编译之后就可以引用到所需要的jar了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android中内存泄漏出现的场景&解决方案]]></title>
        <id>https://merpyzf.github.io/post/android-zhong-nei-cun-xie-lou-chu-xian-de-chang-jing-andjie-jue-fang-an/</id>
        <link href="https://merpyzf.github.io/post/android-zhong-nei-cun-xie-lou-chu-xian-de-chang-jing-andjie-jue-fang-an/">
        </link>
        <updated>2020-04-26T01:49:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="单例模式造成的内存泄漏">单例模式造成的内存泄漏</h2>
<p>单例模式是非常常用的设计模式，使用单例模式的类，只会产生一个对象，这个对象看起来像是一直占用着内存，但这并不意味着就是浪费了内存，内存本来就是拿来装东西的，只要这个对象一直都被高效的利用就不能叫做泄露。<br>
但是过多的单例会让内存占用过多，而且单例模式__由于其静态特性，其生命周期和应用程序的生命周期一致__，不正确地使用单例模式也会造成内存泄露。</p>
<p>一个Android中的单例：</p>
<pre><code>public class SingleInstanceTest {

    private static SingleInstanceTest sInstance;
    private Context mContext;

    private SingleInstanceTest(Context context){
        this.mContext = context;
    }

    public static SingleInstanceTest newInstance(Context context){
        if(sInstance == null){
            sInstance = new SingleInstanceTest(context);
        }
        return sInstance;
    }
}
</code></pre>
<p>上面是一个比较简单的单例模式用法，需要外部传入一个 Context 来获取该类的实例，如果此时传入的 Context 是 Activity 的话，此时单例就有持有该 Activity 的强引用（直到整个应用生命周期结束）。这样的话，即使该 Activity 退出，该 Activity 的内存也不会被回收，这样就造成了内存泄露，特别是一些比较大的 Activity，甚至还会导致 OOM（Out Of Memory）。</p>
<p>解决方法：在单例模式中引用和应用程序生命周期一致的上下文（Application）</p>
<pre><code>public class SingleInstanceTest {

    private static SingleInstanceTest sInstance;
    private Context mContext;

    private SingleInstanceTest(Context context){
        this.mContext = context.getApplicationContext();
    }

    public static SingleInstanceTest newInstance(Context context){
        if(sInstance == null){
            sInstance = new SingleInstanceTest(context);
        }
        return sInstance;
    }
}
</code></pre>
<p>可以看到在 SingleInstanceTest 的构造函数中，将 context.getApplicationContext() 赋值给 mContext，此时单例引用的对象是 Application，而 Application 的生命周期本来就跟应用程序是一样的，也就不存在内存泄露。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[嗨！HTML]]></title>
        <id>https://merpyzf.github.io/post/hai-html/</id>
        <link href="https://merpyzf.github.io/post/hai-html/">
        </link>
        <updated>2020-04-25T15:42:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是html">什么是HTML？</h2>
<p>HTML 全称为 HyperText Markup Language，译为超文本标记语言。<br>
HTML 不是一种编程语言，是一种描述性的标记语言。<br>
作用：HTML是负责描述文档语义的语言。</p>
<h3 id="关于超文本的理解">关于超文本的理解：</h3>
<ol>
<li>HTML可以描述图片、音频、视频、动画、多媒体等内容，超出了只能显示文本内容的限制。</li>
<li>不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。</li>
</ol>
<h3 id="标记语言">标记语言</h3>
<p>HTML不是一种编程语言，是一种描述性的标记语言。这主要有两层含义：</p>
<ol>
<li>标记语言是一套标记标签。比如：标签<code>&lt;a&gt;</code>表示超链接、标签<code>&lt;img&gt;</code>表示图片、标签<code>&lt;h1&gt;</code>表示一级标题等等，它们都是属于 HTML 标签。</li>
<li>编程语言是有编译过程的，而标记语言没有编译过程，HTML标签是直接由浏览器解析执行。</li>
</ol>
<h3 id="负责描述文档的语义">负责描述文档的语义：</h3>
<p>HTML 格式的文件是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述语义，这些标签在浏览器页面上是无法直观看到的，所以称之为“超文本标记语言”。<br>
HTML 中的很多“标签对儿”，这些“标签对儿”能够给文本不同的语义。<br>
比如<h1> 标签，它可以给文本增加标题的语义。</p>
<h3 id="html的专有名词">HTML的专有名词</h3>
<ul>
<li>网页 ：由各种标记组成的一个页面就叫网页。</li>
<li>主页(首页) : 一个网站的起始页面或者导航页面。</li>
<li>标记： 比如<p>称为开始标记 ，</p>称为结束标记，也叫标签。每个标签都规定好了特殊的含义。</li>
<li>元素：比如<p>内容</p>称为元素.</li>
<li>属性：给每一个标签所做的辅助信息。</li>
<li>XHTML：符合XML语法标准的HTML。</li>
<li>DHTML：dynamic，动态的。javascript + css + html合起来的页面就是一个 DHTML。</li>
<li>HTTP：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，- FTP：文件传输协议。</li>
</ul>
<h3 id="一个html页面的骨架">一个Html页面的骨架：</h3>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="文档声明头">文档声明头</h3>
<p>任何一个标准的HTML页面，第一行一定是一个以<!DOCTYPE ……>开头的语句。这一行，就是文档声明头，即 DocType Declaration，简称DTD。<br>
DTD可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</p>
<h4 id="html401有哪些规范呢">HTML4.01有哪些规范呢？</h4>
<p>HTML4.01这个版本是IE6开始兼容的。HTML5是IE9开始兼容的。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。<br>
说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。<br>
HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范。<br>
HTML4.01里面规定了普通和XHTML两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？<code>&lt;H1&gt;&lt;/H1&gt;</code>所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。<br>
总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况：<br>
下面对上图中的三种小规范进行解释：</p>
<ol>
<li>strict：表示“严格的”，这种模式里面的要求更为严格。这种严格体现在哪里？有一些标签不能使用。 比如，u标签，就是给一个本文加下划线，但是这和HTML的本质有冲突，因为HTML最好是只负责语义，不要负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。<br>
那怎么给文本增加下划线呢？今后将使用css属性来解决。<br>
XHTML1.0更为严格，因为这个体系本身规定比如标签必须是小写字母、必须严格闭合标签、必须使用引号引起属性等等。</li>
<li>Transitional：表示“普通的”，这种模式就是没有一些别的规范。</li>
<li>Frameset：表示“框架”，在框架的页面使用。<br>
<strong>在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了。HTML5的DTD（文档声明头）如下：</strong><br>
<code>&lt;!DOCTYPE html&gt;</code></li>
</ol>
<h3 id="页面语言">页面语言</h3>
<p>下面这行标签，用于指定页面的语言类型：<br>
<code>&lt;html lang=&quot;en&quot;&gt;</code><br>
最常见的语言类型有两种：<br>
en：定义页面语言为英语。<br>
zh-CN：定义页面语言为中文。</p>
<h3 id="头标签">头标签</h3>
<p>Html5比较完整的一个骨架：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
	&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
	&lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt;
    &lt;meta name=&quot;Keywords&quot; content=&quot;厉害很厉害&quot; /&gt;
    &lt;meta name=&quot;Description&quot; content=&quot;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>头标签内部的常见标签如下：</p>
<ul>
<li><code>&lt;title&gt;</code>：指定整个网页的标题，在浏览器最上方显示。</li>
<li><code>&lt;base&gt;</code>：为页面上的所有链接规定默认地址或默认目标。</li>
<li><code>&lt;meta&gt;</code>：提供有关页面的基本信息</li>
<li><code>&lt;body&gt;</code>：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。</li>
<li><code>&lt;link&gt;</code>：定义文档与外部资源的关系。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web和Web标准]]></title>
        <id>https://merpyzf.github.io/post/web-he-web-biao-zhun/</id>
        <link href="https://merpyzf.github.io/post/web-he-web-biao-zhun/">
        </link>
        <updated>2020-04-25T15:35:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="web-网页-浏览器">Web、网页、浏览器</h2>
<h3 id="web">Web</h3>
<p>Web（World Wide Web）即全球广域网，也称为万维网。<br>
我们常说的Web端就是网页端。</p>
<h3 id="网页">网页</h3>
<p>网页是构成网站的基本元素。网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。<br>
我们在浏览器上输入网址后，打开的任何一个页面，都是属于网页。</p>
<h3 id="浏览器">浏览器</h3>
<p>浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。</p>
<h2 id="web标准">Web标准</h2>
<h3 id="w3c组织">W3C组织</h3>
<p>W3C：万维网联盟组织，用来制定web标准的机构（组织）。<br>
W3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。<br>
W3C 组织就类似于现实世界中的联合国。<br>
为什么要遵循WEB标准呢？因为很多浏览器的浏览器内核不同，导致页面解析出来的效果可能会有差异，给开发者增加无谓的工作量。因此需要指定统一的标准。</p>
<h3 id="web-标准">Web 标准</h3>
<p>Web标准：制作网页要遵循的规范。<br>
Web标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的集合。</p>
<p>1、Web标准包括三个方面：</p>
<ul>
<li>结构标准（HTML）：用于对网页元素进行整理和分类。</li>
<li>表现标准（CSS）：用于设置网页元素的版式、颜色、大小等外观样式。</li>
<li>行为标准（JS）：用于定义网页的交互和行为。<br>
根据上面的Web标准，可以将 Web前端分为三层，如下。</li>
</ul>
<p>2、Web前端分三层：</p>
<ul>
<li>HTML（HyperText Markup Language）：超文本标记语言。从语义的角度描述页面的结构。相当于人的身体组织结构。</li>
<li>CSS（Cascading Style Sheets）：层叠样式表。从审美的角度美化页面的样式。相当于人的衣服和打扮。</li>
<li>JS：JavaScript。从交互的角度描述页面的行为。相当于人的动作，让人有生命力。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask-SQLAlchemy使用]]></title>
        <id>https://merpyzf.github.io/post/flask-sqlalchemy-shi-yong/</id>
        <link href="https://merpyzf.github.io/post/flask-sqlalchemy-shi-yong/">
        </link>
        <updated>2020-04-25T09:49:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>扩展Flask-SQLAlchemy集成了SQLAlchemy，它简化了连接数据库服务器、管理数据库会话等各类工作，同时也是一个ORM框架。</p>
<h3 id="安装">安装</h3>
<pre><code>pip install flask-sqlalchemy
</code></pre>
<h3 id="在flask环境下使用">在Flask环境下使用</h3>
<pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
db = SQLAlchemy()
db.init_app(app)
</code></pre>
<p>如果未配置SQLALCHEMY_DATABASE_URI，则程序无法连接到数据库服务器，直接执行则会出错。</p>
<h3 id="连接数据库服务器">连接数据库服务器</h3>
<p>DBMS通常会提供一个数据库服务器在操作系统上。要连接数据库服务器。首先要为我们的程序制定一个URI。数据库URI是一个包含了各种属性的字符串。</p>
<h4 id="常用的数据库连接uri">常用的数据库连接URI</h4>
<ul>
<li>PostgreSQL : postgresql+&lt;数据库驱动&gt;://username:password@host:port/databasename</li>
<li>MySQL : mysql+&lt;数据库驱动&gt;://username:password@host:port/databasename</li>
<li>Oracle : oracle+&lt;数据库驱动&gt;://username:password@host:port/databasename</li>
<li>SQLite(UNIX) : sqlite:////dir/sqlite.db</li>
<li>SQLite(Windows) : r'sqlite:///dir\sqlite.db'</li>
</ul>
<p>在Flask-SQLAlchemy中数据库连接uri通过SQLALCHEMY_DATABASE_URI进行配置。</p>
<p>向Flask框架中添加配置:</p>
<pre><code># app.config.update({'SQLALCHEMY_DATABASE_URI': 'mysql://root:wangke0310@127.0.0.1:3306/test'})
or
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:wangke0310@127.0.0.1:3306/test'
</code></pre>
<h3 id="配置警告sqlalchemy_track_modifications">配置警告:SQLALCHEMY_TRACK_MODIFICATIONS</h3>
<p>SQLALCHEMY_TRACK_MODIFICATIONS配置变量决定是否追踪对象的修改，这用于Flask-SQLAlchemy的事件通知系统。这个配置键的值默认为None,如果没有特殊要求，可以将其设置为False以关闭警告信息：</p>
<pre><code>app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
</code></pre>
<h3 id="定义模型类">定义模型类</h3>
<p>用来映射到数据表的Python类通常被称为一个数据库模型（Model）一个数据库模型类对应数据库中的一张表。</p>
<h4 id="使用sqlalchemy定义模型类">使用SQLAlchemy定义模型类</h4>
<pre><code>Base = declarative_base()
class User(Base):
    __tablename__ = 'tab_users'
    id = Column(Integer, primary_key=True)
    name = Column(String(20))
    fullname = Column(String(20))
    password = Column(String(20))
</code></pre>
<p>在使用SQLAlchemy定义模型类时我们需要去继承一个由declarative_base()方法创建的一个基类。</p>
<h4 id="使用flask-sqlalchemy定义模型类">使用Flask-SQLAlchemy定义模型类</h4>
<pre><code>db = SQLAlchemy(app)
</code></pre>
<p>当我们通过Flask-SQLAlchemy来定义模型类时则不再需要向上面一样手动去通过declarative_base()方法去获取一个基类。我们只需要创建一个SQLAlchemy的实例即可，其内部会自动帮助我们创建。</p>
<p>SQLAlchemy类的构造方法：</p>
<pre><code>   def __init__(self, app=None, use_native_unicode=True, session_options=None,
                 metadata=None, query_class=BaseQuery, model_class=Model):

        self.use_native_unicode = use_native_unicode
        self.Query = query_class
        self.session = self.create_scoped_session(session_options)
        self.Model = self.make_declarative_base(model_class, metadata)
        self._engine_lock = Lock()
        self.app = app
        _include_sqlalchemy(self, query_class)

        if app is not None:
            self.init_app(app)

</code></pre>
<p><br>
因此模型类直接继承db.Model即可：</p>
<pre><code>from app import db

Base = declarative_base()
class User(db.model):
    __tablename__ = 'tab_users'
    id = Column(Integer, primary_key=True)
    name = Column(String(20))
    fullname = Column(String(20))
    password = Column(String(20))
</code></pre>
<h3 id="类名到表名的生成规则">类名到表名的生成规则</h3>
<p>类名到表名的转换关系如下：</p>
<p>Message -&gt; message [单个单词转换为小写]</p>
<p>ProposalCategory -&gt; proposal_category [多个单词转换为小写并使用下划线分割每一个单词]</p>
<p>也可以通过{%raw%} <strong>tablename</strong>{%endraw%}  属性来自定义类所对应数据库中表的表名。</p>
<pre><code>class Campus(Base):
    __tablename__ = 'haha'
    id = Column(Integer, autoincrement=True, primary_key=True)
    name = Column(String(24), nullable=False)
    address = Column(String(254), nullable=True)

</code></pre>
<h3 id="常用字段类型">常用字段类型</h3>
<ul>
<li>Integer 整数</li>
<li>String 字符串，指定length来设置所存放字符的最大长度</li>
<li>Text 较长的Unicode文本</li>
<li>Date 日期，存储Python的datetime.date对象</li>
<li>Time 时间，存储Python的datetime.time对象</li>
<li>DateTime 日期时间，存储Python的datetime对象</li>
<li>Interval 时间间隔，存储Python的datetime.timedelta</li>
<li>Float 浮点数</li>
<li>Boolean 布尔值</li>
<li>PickleType 存储Pickle序列化的Python对象</li>
<li>LargeBinary 存储任意二进制文件</li>
</ul>
<h3 id="常用字段参数">常用字段参数</h3>
<p>下面为实例化字段类时常用的字段参数：</p>
<ul>
<li>primary_key : 布尔类型，如果设为True则该字段为主键</li>
<li>unique : 布尔类型，如果设为True则该字段不允许出现重复值</li>
<li>index : 布尔类型，如果设为True则为该字字段创建索引，以提高查询效率</li>
<li>nullable : 布尔类型，确定该字段是否可为空，默认为True</li>
<li>default : 为当前字段设置一个默认值</li>
</ul>
<h3 id="类属性名到数据库表字段名生成规则">类属性名到数据库表字段名生成规则</h3>
<p>字段名默认为类属性名，也可以通过字段类构造方法的第一个参数指定，或者使用关键字name。</p>
<p>通过字段类构造方法第一个参数指定：</p>
<pre><code>   name = Column('name', String(24), nullable=False)
</code></pre>
<p>通过使用关关键字name指定：</p>
<pre><code>name = Column(String(24), nullable=False, name='new_name')
</code></pre>
<h3 id="创建表">创建表</h3>
<p>可以通过调用db.create_all()来把已经定义好的模型类生成数据库中的表。</p>
<p>需要注意有一下几点：</p>
<ol>
<li>
<p>如果模型类是单独定义在别的模块中的，在调用db.create_all()前要导入相应的模块。确保其被加载到了内存。</p>
</li>
<li>
<p>执行db.create_all()需要上下文环境，可以通过下面的方式创建一个上下文环境：</p>
</li>
</ol>
<pre><code>with app.app_context():
    db.create_all()
</code></pre>
<ol start="3">
<li>使用db.create_all()只会创建和模型类相对应的表，而不会创建数据库。因此在调用此方法前需要确保要操作的数据库已经被创建。</li>
</ol>
<p>数据库和表一旦被创建模型类的改动就不会自动作用到实际的表中。比如在模型类中添加或删除了一个字段，修改字段的名称和类型。这时再次调用create_all()也不会更新表结构。如果想要数据库中的表结构能够生效则需要先调用db.drop_all()删除数据库中的所有表，再调用db.create_all()才会生效。</p>
<p>在开发时，以删除表再重建的方式更新数据库简单直接，但是明显的缺陷就会丢掉已的数据。在生产环境中肯定是不以这样的。我们可以通过flask-migrate来帮我们实现数据库的迁移，数据库迁移工具可以在不破坏数据的情况下更新数据库表结构。</p>
<h3 id="flask-migrate">flask-migrate</h3>
<p><a href="https://alembic.sqlalchemy.org/en/latest/">Alembic文档</a></p>
<p>扩展flask-migrate集成了Alembic(和SQLAlchemy是同一个作者)它提供了一些flask命令来简化我们的工作。</p>
<p>将flask-migrate集成到我们的项目非常简单:</p>
<pre><code> migrate = Migrate(app, db)
</code></pre>
<p>实例化Migrate类并传递两个参数即可。</p>
<ul>
<li>参数1: Flask实例对象</li>
<li>参数2: SQLAlchemy实例对象</li>
</ul>
<p>配置好之后就可以通过flask命令还来执行数据库迁移工作。在使用命令前要确保FLASK_APP配置正确，否则命令无法执行。</p>
<h4 id="数据库迁移命令">数据库迁移命令</h4>
<ul>
<li>创建迁移环境 : flask db init</li>
<li>生成迁移脚本 : flask db migrate -m &quot;add column remark&quot;</li>
<li>更新数据库 : flask db upgrade</li>
<li>回退到上一个数据库版本 : flask db downgrade</li>
</ul>
<h3 id="简单数据库操作">简单数据库操作</h3>
<p>下面关于简单数据库操作使用Campus类进行演示:</p>
<pre><code>class Campus(Base):
    id = Column(Integer, autoincrement=True, primary_key=True)
    # 校区名
    name = Column(String(24), nullable=False)
    # 校区地址
    address = Column(String(254), nullable=True)
</code></pre>
<h4 id="查询操作">查询操作</h4>
<p>一个完整的查询应该遵循下面的模式：</p>
<p>&lt;模型类&gt;.query.&lt;过滤方法&gt;.&lt;查询方法&gt;</p>
<p>或者:</p>
<p>query(&lt;模型类&gt;).&lt;过滤方法&gt;.&lt;查询方法&gt;</p>
<h5 id="all-查询所有的地址列表">all() 查询所有的地址列表</h5>
<pre><code>list = Campus.query.all()
or
list = db.session.query(Campus).query.all()
</code></pre>
<h5 id="first-查询地址id为1的行">first() 查询地址id为1的行</h5>
<pre><code>campus = Campus.query.filter(Campus.id == 1).first()
</code></pre>
<h5 id="count-查询记录总数">count() 查询记录总数</h5>
<pre><code>count = Campus.query.count()
</code></pre>
<h5 id="常用查询方法">常用查询方法:</h5>
<ul>
<li>all() 返回包含所有查询记录的列表</li>
<li>first() 返回查询的第一条记录，如果未找到返回None</li>
<li>first_or_404() 返回查询的第一条记录，如果未找到则返回404响应给客户端</li>
<li>one() 返回查询到的第一条记录，且整个查询到的记录数只允许为1，否则抛出错误</li>
<li>one_or_none() 返回查询到的第一条记录，如果查询到的记录数不为1，则返回None</li>
<li>get(ident) 传入主键作为参数，返回指定主键所对应的记录，如果未找到则返回None</li>
<li>get_or_404(ident) 传入主键作为参数，返回指定主键所对应的记录，如果未找到返回一个404响应给客户端</li>
<li>count() 返回查询结果的数量</li>
<li>paginate() 返回一个paginate对象，可以对记录进行分页处理</li>
</ul>
<h5 id="常用的过滤方法">常用的过滤方法</h5>
<ul>
<li>filter() 使用指定的规则过滤，返回新的查询对象</li>
<li>filter_by() 使用指定的规则过滤（以关键字表达式的形式），返回新产生的查询对象</li>
<li>order_by() 根据指定的规则对查询到的结果进行排序，返回新产生的查询对象</li>
</ul>
<pre><code>list = Campus.query.order_by(Campus.id.desc()).all()
</code></pre>
<ul>
<li>limit(limit) 使用指定的值限制原查询记录返回的数量，返回新产生的查询对象</li>
<li>group_by() 根据指定条件对记录进行分组，返回新产生的查询对象</li>
<li>offset(offset) 使用指定的值偏移原查询结果，返回新产生的查询对象</li>
</ul>
<h5 id="聚合操作">聚合操作</h5>
<p>需要从： from sqlalchemy.sql import func 引入</p>
<ul>
<li>func.max() 根据参数指定的列取所有记录中最大的那个</li>
</ul>
<pre><code>max_id = db.session.query(func.max(Campus.id)).first()
</code></pre>
<ul>
<li>func.sum() 对指定的列执行累加操作</li>
</ul>
<pre><code>  sum_id = db.session.query(func.sum(Campus.id)).first()
</code></pre>
<ul>
<li>func.min() 根据参数指定的列取所有记录中最小的那个</li>
</ul>
<pre><code>  min_id = db.session.query(func.min(Campus.id)).first()
</code></pre>
<h5 id="filter常用的过滤操作">filter()常用的过滤操作：</h5>
<ul>
<li>== :</li>
</ul>
<pre><code>filter(Campus.id == 1)
</code></pre>
<ul>
<li>!= :</li>
</ul>
<pre><code>filter(Campus.id != 1)
</code></pre>
<ul>
<li>LIKE :</li>
</ul>
<pre><code>filter(Campus.address.like('%汊河%'))
</code></pre>
<ul>
<li>IN :</li>
</ul>
<pre><code>filter(Campus.name.in_(['mingjia', 'zhihu']))
</code></pre>
<ul>
<li>NOT IN :</li>
</ul>
<pre><code> filter(~Campus.name.in_(['mingjia', 'zhihu']))
</code></pre>
<ul>
<li>AND :</li>
</ul>
<pre><code># 1.使用and_ 
filter(and_(Campus.id == 1, Campus.name == 'zhihu'))
#2. 直接在filter中添加多个表达式使用逗号分隔 
filter(Campus.id == 1, Campus.name == 'zhihu')
#3. 叠加使用对个filter或filter_by方法 
filter(Campus.id == 1).filter(Campus.name == 'zhihu') 
</code></pre>
<ul>
<li>OR :</li>
</ul>
<pre><code>filter(or_(Campus.id == 1, Campus.name == 'mingjia' ))
</code></pre>
<p><a href="http://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators">完整的操作符列表</a></p>
<h5 id="filter与filter_by的区别">filter与filter_by的区别</h5>
<p>通过filter_by可以直接使用 关键字表达式 来指定过滤规则，而filter只需要通多传递参数的形式来指定过滤规则。</p>
<p>使用filter和filter_by实现同样的查询功能：</p>
<p>filter:</p>
<pre><code>campus = Campus.query.filter(Campus.id == 1).first()
</code></pre>
<p>filter_by:</p>
<pre><code>campus = Campus.query.filter_by(id = 1).first()
</code></pre>
<h4 id="更新操作">更新操作</h4>
<p>直接赋值给模型类的字段属性就可以完成更新的操作</p>
<pre><code>campus = Campus.query.get(1)
campus.name = '四望亭校区'
db.session.commit()
</code></pre>
<p>注意： 只有要插入新的记录或者将现有的记录添加到会话中才需要使用add,单纯的更新记录时只需要为属性赋新值，并提交修改。</p>
<h4 id="删除操作">删除操作</h4>
<pre><code>campus = Campus.query.filter_by(id &gt; 2).delete()
db.session.commit()

</code></pre>
<h3 id="高级数据库操作">高级数据库操作</h3>
<h4 id="执行原生sql">执行原生SQL</h4>
<pre><code># 查询
cursor = db.session.execute('select *from student')
print(cursor.fetchall())

# 插入
db.session.execute('insert into student(name) values(:value)', params={'value': 'wangk1e'})
db.session.commit()
</code></pre>
<h4 id="join查询">join查询</h4>
<pre><code>data = db.session.query(Student).join(Guardian, isouter = True).all()
</code></pre>
<p>由于Student模型和Guardian模型之间存在主外键关系，因此可以不用指定任何条件就可以实现连接查询。<br>
join中的isouter参数用于指定两张连接时是采用外连接还是内连接。</p>
<p>也可以手动指定两个模型之间的关联条件:</p>
<pre><code> data = db.session.query(Student).join(Guardian, Student.guardian_id == Guardian.id, isouter = False).all()
</code></pre>
<h5 id="多个模型关联查询">多个模型关联查询</h5>
<pre><code>  query = db.session.query(Student).join(Student.guardian, isouter=True) \
            .join(Student.local_school, isouter=True) \
            .join(Student.course, isouter=True) \
            .join(Student.category, isouter=True) \
            .order_by(sort)
</code></pre>
<h5 id="内连接和外链接的区别">内连接和外链接的区别</h5>
<ol>
<li>
<p>内连接： 从左表中取出一条记录去和右表中的所有记录根据条件进行匹配，只有匹配得上才会保留内容。也就是两张表根据某个条件取交集。</p>
</li>
<li>
<p>外连接： 从左表中取出一条记录去和右表中的所有记录根据条件进行匹配，无论是否匹配得上都会保留内容。不能匹配的其他表中的内容为null。</p>
</li>
</ol>
<h5 id="示例1">示例1</h5>
<pre><code>            q = session.query(Address).select_from(User).\
                            join(User.addresses).\
                            filter(User.name == 'ed')
    
        Which will produce SQL similar to::

            SELECT address.* FROM user
                JOIN address ON user.id=address.user_id
                WHERE user.name = :name_1
</code></pre>
<h5 id="示例2">示例2</h5>
<pre><code>            address_subq = session.query(Address).\
                            filter(Address.email_address == 'ed@foo.com').\
                            subquery()

            q = session.query(User).join(address_subq, User.addresses)

        Producing SQL similar to::

            SELECT user.* FROM user
                JOIN (
                    SELECT address.id AS id,
                            address.user_id AS user_id,
                            address.email_address AS email_address
                    FROM address
                    WHERE address.email_address = :email_address_1
                ) AS anon_1 ON user.id = anon_1.user_id

</code></pre>
<h5 id="示例3">示例3</h5>
<pre><code>            a_alias = aliased(Address)

            q = session.query(User).\
                    join(User.addresses).\
                    join(a_alias, User.addresses).\
                    filter(Address.email_address=='ed@foo.com').\
                    filter(a_alias.email_address=='ed@bar.com')

        Where above, the generated SQL would be similar to::

            SELECT user.* FROM user
                JOIN address ON user.id = address.user_id
                JOIN address AS address_1 ON user.id=address_1.user_id
                WHERE address.email_address = :email_address_1
                AND address_1.email_address = :email_address_2
</code></pre>
<h3 id="func的使用">func的使用</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决 adb 安装 apk 出现 Failure [INSTALL_FAILED_TEST_ONLY] 错误]]></title>
        <id>https://merpyzf.github.io/post/jie-jue-adb-an-zhuang-apk-chu-xian-failure-install_failed_test_only-cuo-wu/</id>
        <link href="https://merpyzf.github.io/post/jie-jue-adb-an-zhuang-apk-chu-xian-failure-install_failed_test_only-cuo-wu/">
        </link>
        <updated>2020-04-02T13:12:03.000Z</updated>
        <content type="html"><![CDATA[<p>平台版本是android 7.0，在adb install *.apk 会提示下面的错误：<br>
Failure INSTALL_FAILED_TEST_ONLY</p>
<h2 id="方法1">方法1：</h2>
<p>修改AndroidManifest.xml 中android:testOnly=&quot;true&quot; 改成 android:testOnly=&quot;false&quot;，或者直接去掉。</p>
<h2 id="方法2">方法2：</h2>
<p>adb push <em>.apk /tmp<br>
adb shell pm install -t /tmp/</em>.apk</p>
<h2 id="方法3">方法3：</h2>
<p>adb install -t *.apk</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《JavaScript高级程序设计》读书笔记]]></title>
        <id>https://merpyzf.github.io/post/lesslessjavascript-gao-ji-cheng-xu-she-ji-greatergreater-du-shu-bi-ji/</id>
        <link href="https://merpyzf.github.io/post/lesslessjavascript-gao-ji-cheng-xu-she-ji-greatergreater-du-shu-bi-ji/">
        </link>
        <updated>2020-03-28T16:31:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第三章">第三章</h1>
<h2 id="with语句">with语句</h2>
<p>with语句的作用就是将代码的作用域设置到一个特定的对象中。<br>
定义with语句的主要目的主要是为了简化多次编写同一个对象的工作，如👇所示：</p>
<pre><code>var qs = location.search.substring(1);
var hostname = location.hostname;
var url = location.href;
</code></pre>
<p>以上几行代码都涉及到对location对象的操作，如果使用with语句，可以把上面的代码改成如下所示：</p>
<pre><code>with(location){
    var qs = search.substring(1);
    var hostname = hostname;
    var url = href;
}
</code></pre>
<p>在这个重写的例子中，使用with语句关联了location对象。这意味着在with语句中的代码块内部，每个变量首先会被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查找location对象中是否有同名的属性。如果发现了同名的属性，则以location对象的值作为变量中值。</p>
<p>__ 严格模式下不允许使用with语句，否则将被视为语法错误🙅（大量的使用with语句会导致性能下降，也会给调试代码造成困难） __</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Cordova&IonicNative插件开发遇到的一些坑]]></title>
        <id>https://merpyzf.github.io/post/guan-yu-cordovaandionicnative-cha-jian-kai-fa-yu-dao-de-yi-xie-keng/</id>
        <link href="https://merpyzf.github.io/post/guan-yu-cordovaandionicnative-cha-jian-kai-fa-yu-dao-de-yi-xie-keng/">
        </link>
        <updated>2020-03-16T03:32:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-在ionic-native下编译生成的类型声明包中的js文件内会对cordova进行重复引用">1. 在ionic-native下编译生成的类型声明包中的js文件内会对cordova进行重复引用：</h3>
<figure data-type="image" tabindex="1"><img src="https://merpyzf.github.io/post-images/1584329762977.png" alt="" loading="lazy"></figure>
<p>解决方法：删除多余引入的cordova模块</p>
<h3 id="2-在类型声明文件indexdts中为调用native层功能的方法的返回结果指定为observable不生效">2. 在类型声明文件index.d.ts中为调用Native层功能的方法的返回结果指定为Observable不生效：</h3>
<p>index.d.ts文件内部方法声明：</p>
<pre><code>  /**
   * 开启对条码扫描结果的接收
   */
  @cordova()
  openScanReceiver(): Observable&lt;any&gt; {
    return;
  }
</code></pre>
<p>解决方法：<br>
<img src="https://merpyzf.github.io/post-images/1584330103891.png" alt="" loading="lazy"><br>
给以上截图中的两个index.js补充 <code>{&quot;observable&quot;: true }</code></p>
<h3 id="2-pluginresultstatusok-设置插件结果返回的状态明明是ok最后回调却是error">2. PluginResult.Status.OK 设置插件结果返回的状态明明是OK最后回调却是error</h3>
<pre><code>       PluginResult pr = new PluginResult(PluginResult.Status.OK, barcode);
       pr.setKeepCallback(true);
       barCodeCallbackContext.sendPluginResult(pr);
</code></pre>
<p>这个坑踩了一个上午！一个低级错误，<strong>注意检查插件的调用和插件中方法签名的声明是否一致！比如这里就漏掉了一个参数。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[adb error: more than one device]]></title>
        <id>https://merpyzf.github.io/post/adb-error-more-than-one-device/</id>
        <link href="https://merpyzf.github.io/post/adb-error-more-than-one-device/">
        </link>
        <updated>2020-03-16T02:58:24.000Z</updated>
        <content type="html"><![CDATA[<p>You can run every command of adb by selecting the device by deviceID. run command to get Device Id:</p>
<pre><code>adb devices
</code></pre>
<p>you will get the list of all available devices something like this:</p>
<pre><code>&lt;device ID&gt; device
emulator-5554 offline
</code></pre>
<p>the copy the device id run commad like this:</p>
<pre><code>adb -s &lt;device ID&gt; &lt;your command&gt;
</code></pre>
<p>example:</p>
<pre><code>adb -s &lt;device ID&gt; tcpip 5555
</code></pre>
<p>OR</p>
<pre><code>adb -s &lt;device ID&gt; forward tcp:59900 tcp:59900
</code></pre>
<p>this will not get the error like &quot;more than one device/emulator&quot;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于Cordova创建Ionic插件]]></title>
        <id>https://merpyzf.github.io/post/ji-yu-cordova-chuang-jian-ionic-cha-jian/</id>
        <link href="https://merpyzf.github.io/post/ji-yu-cordova-chuang-jian-ionic-cha-jian/">
        </link>
        <updated>2020-03-13T10:16:43.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>克隆Github中的Ionic-Native的项目到本地，后面命令的执行和插件文件模版的生成需要依赖此环境。</p>
</li>
<li>
<p>进入ionic-native的根目录</p>
</li>
<li>
<p>创建插件包</p>
<pre><code>// 调用此命令，并将`PluginName`替换为希望添加的插件名称
// 第一个字母一定要大写，使用大驼峰命名
gulp plugin:create -n PluginName
</code></pre>
<p>执行完以上命令将会在src/@ionic-native/plugins目录下创建一个名称为PluginName的插件目录，里面有一个index.ts文件，后面Ionic插件的编写就是需要在这个文件中进行的。</p>
</li>
<li>
<p>编写index.ts</p>
<pre><code>@Plugin({
pluginName: 'ZijinUtilPlugin',
plugin: 'cordova-plugin-x-zijinutil', // npm package name, example: cordova-plugin-camera
pluginRef: 'cordova.plugins.ZijinUtil', // the variable reference to call the plugin, example: navigator.geolocation
platforms: ['Android'] // Array of platforms supported, example: ['Android', 'iOS']
})
@Injectable()
export class ZijinUtilPlugin extends IonicNativePlugin {
}
</code></pre>
</li>
</ol>
<p>这里需要重点指出的是 @Plugin装饰器中参数的添加：</p>
<ol>
<li>
<p>pluginRef：指的是底层Cordova插件的应用方式，这个值和cordova插件中的plugin.xml下的clobbers节点值相同。</p>
</li>
<li>
<p>plugin：值的是npm包的名称</p>
</li>
<li>
<p>通过调用 npm run build <pluginName> 来完成对插件的编辑，最后编译的结果会生成到ionic-native/dist/@ionic-native/plugins目录。如果是使用的是MacOS系统进行的编译还有可能会出现如下的错误：<code>Error: ENOENT: no such file or directory, open '/Users/wangke/Workspace/CompanyProjects/ionic-native/dist/@ionic-native/plugins/.DS_Store/index.js'</code>。通过执行 find . -name '.DS_Store' -type f -delete 命令后即可解决上述问题。</p>
</li>
</ol>
]]></content>
    </entry>
</feed>